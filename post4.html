<!DOCTYPE html>
<html>
<head>
	<title>Post Name</title>


	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1" />

	<link href="https://fonts.googleapis.com/css2?family=Russo+One&display=swap" rel="stylesheet">

	<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@500&display=swap" rel="stylesheet">

	<link rel="stylesheet" type="text/css" href="default.css">


	<style type="text/css">
		.img-container{
			max-width: 600px;
		}

		img{
			width: 100%
		}

	</style>

</head>
<body>
	<div class="nav-wrapper">

		<!-- Link around dots-wrapper added after tutorial video -->
		<a href="index.html">
			<div class="dots-wrapper">
				<div id="dot-1" class="browser-dot"></div>
				<div id="dot-2" class="browser-dot"></div>
				<div id="dot-3" class="browser-dot"></div>
			</div>
		</a>

		<ul id="navigation">
			<li><a href="index.html#contact">Contact</a></li>

		</ul>
	</div>

	<div class="main-container">
		<br>

		<div class="img-container">
			<img src="images/docker.png">
		</div>
		
		<h3>Static Portfolio  to Django Website</h3>
		<p>Docker is a set of platform as a service products that use OS-level virtualisation to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels. All containers are run by a single operating-system kernel and are thus more lightweight than virtual machines.[8]
		</p>
		<h6>What is Container?</h6>
		<p>Docker Container is a standardised unit which can be created on the fly to deploy a particular application or environment. It could be an Ubuntu container, CentOs container, etc. to full-fill the requirement from an operating system point of view. Also, it could be an application oriented container like CakePHP container or a Tomcat-Ubuntu container etc.
		</p>
		<h6>Docker Concepts</h6>
		<p>Docker is a platform for developers and sysadmins to build, share, and run applications with containers. The use of containers to deploy applications is called containerisation. Containers are not new, but their use for easily deploying applications is.</p>
		<p>Containerisation is increasingly popular because containers are:
		</p>
		<p>Flexible: Even the most complex applications can be containerised.
		</p>
		<p>Lightweight: Containers leverage and share the host kernel, making them much more efficient in terms of system resources than virtual machines.
		</p>
		<p>Portable: You can build locally, deploy to the cloud, and run anywhere.
		</p>
		<p>Loosely coupled: Containers are highly self sufficient and encapsulated, allowing you to replace or upgrade one without disrupting others.
		</p>
		<p>Scalable: You can increase and automatically distribute container replicas across a datacenter.
		</p>
		<p>Secure: Containers apply aggressive constraints and isolations to processes without any configuration required on the part of the user.
		</p>
		<div class="img-container">
			<img src="images/docker-2.PNG">
		</div>
		<h6>Images and containers
		</h6>
		<p>Fundamentally, a container is nothing but a running process, with some added encapsulation features applied to it in order to keep it isolated from the host and from other containers. One of the most important aspects of container isolation is that each container interacts with its own, private filesystem; this filesystem is provided by a Docker image. An image includes everything needed to run an application — the code or binary, runtimes, dependencies, and any other filesystem objects required.
		</p>
		<h6>Containers and virtual machines
		</h6>
		<p>A container runs natively on Linux and shares the kernel of the host machine with other containers. It runs a discrete process, taking no more memory than any other executable, making it lightweight.
			By contrast, a virtual machine (VM) runs a full-blown “guest” operating system with virtual access to host resources through a hypervisor. In general, VMs incur a lot of overhead beyond what is being consumed by your application logic.</p>
		<p>Why do we use docker?
		</p>
		<p>Docker provides us with containers. And containerization consists of an entire runtime environment, an application, all its dependencies, libraries, binaries and configuration files needed to run it, bundled into one package. Each application runs separately from the other. Docker solves the dependency problem by keeping the dependency contained inside the containers. It unites developers against dependency of their project.
		</p>
		<p>Benefits of using Containers over Virtual Machines
		</p>
		<p>Unlike VMs( Virtual Machines ) that run on a Guest OS, using a hypervisor, Docker containers run directly on a host server (for Linux), using a Docker engine, making it faster and lightweight.
		</p>
		<p>Docker containers can be easily integrated compared to VMs.
		</p>
		<p>With a fully virtualized system, you get more isolation. However, it requires more resources. With Docker, you get less isolation. However, as it requires fewer resources, you can run thousands of container on a host.
		</p>
		<p>A VM can take a minimum of one minute to start, while a Docker container usually starts in a fraction of seconds.
		</p>
		<p>Containers are easier to break out of than a Virtual Machine.
		</p>
		<p>Unlike VMs there is no need to preallocate the RAM. Hence docker containers utilize less RAM compared to VMs. So only the amount of RAM that is required is used.
		</p>
		<div class="img-container">
			<img src="images/docker-3.PNG">
		</div>
		<p>Install Docker Desktop
		</p>
		<p>The best way to get started developing containerized applications is with Docker Desktop, for OSX or Windows. Docker Desktop will allow you to easily set up Kubernetes or Swarm on your local development machine, so you can use all the features of the orchestrator you’re developing applications for right away, no cluster required. Follow the installation instructions appropriate for your operating system:
		</p>
		<p>1. docker –version - This command is used to get the currently installed version of docker
		</p>
		<p>2. docker pull - This command is used to pull images from the docker repository(hub.docker.com)
		</p>
		<p>3. docker run - This command is used to create a container from an image
		</p>
		<p>4. docker ps - This command is used to list the running containers
		</p>
		<p>5. docker ps -a - This command is used to show all the running and exited containers
		</p>
		<p>6. docker exec - This command is used to access the running container
		</p>
		<p>7. docker stop - This command stops a running container
		</p>
		<p>8. docker kill - This command kills the container by stopping its execution immediately. The difference between ‘docker kill’ and ‘docker stop’ is that ‘docker stop’ gives the container time to shutdown gracefully, in situations when it is taking too much time for getting the container to stop, one can opt to kill it
		</p>
		<p>9. docker commit - This command creates a new image of an edited container on the local system
		</p>
		<p>10. docker login - This command is used to login to the docker hub repository
		</p>
		<p>11. docker push - This command is used to push an image to the docker hub repository
		</p>
		<p>12. docker images - This command lists all the locally stored docker images
		</p>
		<p>13. docker rm - This command is used to delete a stopped container
		</p>
		<p>14. docker rmi - This command is used to delete an image from local storage
		</p>
		<p>15. docker build - This command is used to build an image from a specified docker file
		</p>
	</div>

</body>
</html>